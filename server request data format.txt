This is all WIP and subject to change based on whatever makes the RDV connector
easier to implement. (I'll keep this document updated throughout, of course.)

Data format:

Header (t, n):
t (1 byte) - request type
n (4 bytes, little-endian) - size in bytes of the following data

Request data:

Type 0 - Get server info
  data: none (ignored)
  server response: header (0, n) + n-byte JSON string describing the current game:
    {
    	"api_version": 0,
    	"platform": "freeware",
    	"uuid": "{00000000-0000-0000-0000-000000000000}",
    	"offsets": {
    		"flags": 4840864,
    		"map_flags": 4842936
    	}
    }   

Type 1 - Execute a script
  data: n-byte script to be executed
  server response:
    if script was queued for execution successfully, header (1, 0) + no data
    if something went wrong, header (-1, m) + m byte string describing the error

Type 2 - Get flag state
  data: array of n/4 signed 4-byte flag numbers, little-endian
  server response: header (2, n/4) + array of 1-byte 0/1 values corresponding to the
                   state of the requested flags

Type 3 - Queue multiple event numbers
  data: array of n/4 signed 4-byte event numbers, little-endian
        (the events will be ran sequentially within the current map's script,
        so you'd best only specify events from Head.tsc!)
  server response:
    on success, header (3, 0) + no data
    on failure, header (-1, m) + m byte string describing the error

Type 4 - Read memory
  data: 4-byte starting address + unsigned 2-byte count (both little-endian)
  server response:
    on success, header (4, count) + array of count bytes which are the contents of
                the game process's memory starting at the requested address
    on failure, header (-1, m) + m byte string describing the error

Type 5 - Write memory
  data: 4-byte starting address, little endian + array of n-4 bytes to be written
        to the game process's memory starting at that address
  server response:
    on success, header (5, 0) + no data
    on failure, header (-1, m) + m byte string describing the error

Type 6 - Query game state
  data: none or 1 byte request type
  server response:
   if request type == 0 or blank:
     header (6, 1) + 1 byte denoting the current game execution state:
     0: intro cutscene (ModeOpening())
     //1: title screen (ModeTitle()) (disabled, not working)
     2: main game loop (ModeAction())
     3: inventory screen (CampLoop())
     4: teleporter menu (StageSelectLoop())
     5: minimap display (MiniMapLoop())
     6: island falling cutscene (Scene_DownIsland())
     7: Esc menu (Call_Escape())
    -1: none of the above (game initializing/de-initializing or title screen ;) )
   if request type == 1:
     header (6, m) + m byte string containing the current (internal) map name

Type -1 (255) - Disconnect
 The client can just close the connection itself, so you probably don't actually
 need this. But if you want the server to close the connection instead then
 here you go, I guess...(this command only closes the current connection, not the
 entire server)
  data: none
  server response: none (connection will be closed)
